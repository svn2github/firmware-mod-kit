--- unpack.c	2010-11-07 04:32:14.000000000 +0100
+++ bff_huffman_decompress.c	2013-03-28 22:48:23.409662892 +0100
@@ -1,10 +1,9 @@
-/*	$FreeBSD: head/usr.bin/gzip/unpack.c 194579 2009-06-21 09:39:43Z delphij $	*/
-/*	$NetBSD: unpack.c,v 1.2 2010/11/06 21:42:32 mrg Exp $	*/
-
 /*-
  * Copyright (c) 2009 Xin LI <delphij@FreeBSD.org>
  * All rights reserved.
  *
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -27,15 +26,14 @@
  * SUCH DAMAGE.
  */
 
-/* This file is #included by gzip.c */
+// compile it using: gcc bff_huffman_decompress.c -o bff_huffman_decompress
+// use it as: ./bff_huffman_decompress sampleBff_file0 sampleBff_file0_parsed 
 
 /*
  * pack(1) file format:
  *
- * The first 7 bytes is the header:
- *	00, 01 - Signature (US, RS), we already validated it earlier.
- *	02..05 - Uncompressed size
- *	    06 - Level for the huffman tree (<=24)
+ * The first byte is the header:
+ *	    00 - Level for the huffman tree (<=24)
  *
  * pack(1) will then store symbols (leaf) nodes count in each huffman
  * tree levels, each level would consume 1 byte (See [1]).
@@ -56,7 +54,10 @@
  * range [0..254], so all levels' symbol count would fit into 1 byte.
  */
 
-#define	PACK_HEADER_LENGTH	7
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#define	PACK_HEADER_LENGTH	1
 #define	HTREE_MAXLEVEL		24
 
 /*
@@ -87,6 +88,13 @@
 	FILE		*fpOut;		/* Output stream */
 } unpack_descriptor_t;
 
+int maybe_err(char*fmt,...) {
+
+}
+int maybe_errx(char*fmt,...) {
+
+}
+
 /*
  * Release resource allocated to an unpack descriptor.
  *
@@ -164,15 +172,11 @@
 
 	accepted_bytes(bytes_in, PACK_HEADER_LENGTH);
 
-	/* Obtain uncompressed length (bytes 2,3,4,5)*/
+	/* Reset uncompressed size */
 	unpackd->uncompressed_size = 0;
-	for (i = 2; i <= 5; i++) {
-		unpackd->uncompressed_size <<= 8;
-		unpackd->uncompressed_size |= hdr[i];
-	}
 
 	/* Get the levels of the tree */
-	unpackd->treelevels = hdr[6];
+	unpackd->treelevels = hdr[0];
 	if (unpackd->treelevels > HTREE_MAXLEVEL || unpackd->treelevels < 1)
 		maybe_errx("Huffman tree has insane levels");
 
@@ -247,7 +251,7 @@
  * Decode huffman stream, based on the huffman tree.
  */
 static void
-unpack_decode(const unpack_descriptor_t *unpackd, off_t *bytes_in)
+unpack_decode(unpack_descriptor_t *unpackd, off_t *bytes_in)
 {
 	int thislevel, thiscode, thisbyte, inlevelindex;
 	int i;
@@ -285,8 +289,7 @@
 
 				thissymbol =
 				    &(unpackd->tree[thislevel][inlevelindex]);
-				if ((thissymbol == unpackd->symbol_eob) &&
-				    (bytes_out == unpackd->uncompressed_size))
+				if (thissymbol == unpackd->symbol_eob)
 					goto finished;
 
 				fputc((*thissymbol), unpackd->fpOut);
@@ -305,6 +308,7 @@
 finished:
 	if (bytes_out != unpackd->uncompressed_size)
 		maybe_errx("Premature EOF");
+    unpackd->uncompressed_size=bytes_out;  // hack
 }
 
 /* Handler for pack(1)'ed file */
@@ -320,4 +324,38 @@
 	/* If we reached here, the unpack was successful */
 	return (unpackd.uncompressed_size);
 }
+void
+usage() {
+    printf("Usage:\n    ./bff_huffman_decompress INFILE OUTFILE\n");
+}
+int
+main(int argc,char**argv) {
+    if (argc<3) {
+        fprintf(stderr,"[!] Please specify the input and output file as command line arguments\n");
+        usage();
+        return 1;
+    }
+    FILE*in=fopen(argv[1],"r");
+    if (!in) {
+        fprintf(stderr,"[-] Could *not* open input file\n");
+        return 1;
+    }
+    int in_fd=fileno(in);
+    FILE*out=fopen(argv[2],"w");
+    if (!out) {
+        fprintf(stderr,"[-] Could *not* open output file\n");
+        return 1;
+    }
+    int out_fd=fileno(out);
+    off_t uncompressed_size=unpack(in_fd,out_fd,0,0,0);
+    if (uncompressed_size>0) {
+        printf("[+] File was successfully decompressed, decompressed size is %lu (%luKB)\n",
+            uncompressed_size,uncompressed_size/1024);
+        return 0;
+    } else {
+        fprintf(stderr,"[-] Decompression of the file *not* succeeded. FAILED!\n");
+        return 1;
+    }
+    return 0;
+}
 
